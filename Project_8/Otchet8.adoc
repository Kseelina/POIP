---
title: Отчёт 8
---

:reproducible:

:description: Project_8
:keywords: AsciiDoc
:imagesdir: Project_8
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[.notes]
С++ - объекто-ориентированный язык программирования, это означает, что он
построен на классах и объектах. И в нём действуют 4 главных правила:

1. Абстракция. Это создание и описание объекта и его функций (методов).
2. Наследование. Это, когда созданный объект перенимает свойства родительского объекта.
3. Инкапсуляция. Это сокрытие от пользователя функционала объектов, на
основе которых состоит более сложный объект.
4. Полиморфизм. Это присваение двум разным объектам одни и теже поведенческих функции (методы).


== Постановка задачи
Для того, чтобы написать правильно работающий код с возможностью
расширения функционала, необходимо продумать дизайн программы.
Продумка дизайна позволит писать код проще (т.е. строчки кода будут короче и читабельнее),
а также позволит адаптировать программу.

По заданию требуется написать программу "Гирлянда", которая может
управлять светодиодами, и по кнопке переключать режимы:

- мигание всеми светодиодами
- мигание светодиодами в шахматном порядке
- "Ёлочка"

Как уже было сказано, разработку программы стоит начинать с дизайна.
Для этих целей хорошо подойдёт UML диаграмма, котора позволит выстроить
логические цепочки.

Сперва необходимо определиться с абстракциями (т.е. существительными, объектами, которые
будут присутствовать в гирлянде). Любая абстракция представляется классом, который имеет описание.
В данном случае абстракциями будут:

- пины (Pin)
- кнопка (Button)
- светодиоды (LED)
- режимы (IMode)
- гирлянда (Garland)

Другими словами, мы создаём гирлянду, которая по нажатию кнопки, переключает режимы, которые
по-разному светят светодиодами, которые прикреплены к пину (ножке микроконтроллера).

Исходя из поставленной задачи будем по ней двигаться с конца в начало, для того, чтобы сперва
описать внутренние составляющие гирлянды (пины), затем светодиоды, затем режимы и в конце саму гирлянду.

Первая абстракция будет *Pin*, у которого есть 2 состояния: быть включенным и быть выключенным.
Так же, пин может переключаться из состояния 1 в 0 и наоборот, а ещё с пина можно считать его состояние.
К тому же пин привязан к порту и чтобы была возможность передавать на пин любой порт (GPIOA,
GPIOB, GPIOC и т.д.) с любым номером порта, можно создать шаблонный класс, в который будем передавать
порт и номер порта.

Таким образом мы создаём класс *pin* и два интерфейса от которых будет наследоваться пин:

- *IPinReadable*, который будет наследоваться пином, отвечающим за кнопку.
- *IPin*, который будет наследоваться пином, отвечающим за светодиод.

В этих интерфейсах функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в заголовочном файле *pin.h*.

.Создание класса *Pin* и интерфейсов *IPinReadable* и *IPin*
image::Создание объекта Pin и интерфейсов .png[]

.Класс pin.h
[source, c++]
-------
#ifndef PIN_H //Защита от двойного подключения заголовочного файла
#define PIN_H //Защита от двойного подключения заголовочного файла

#include "ipin.h" // подключение интерфейса
#include "IPinReadable.h" // подключение интерфейса

template<typename TPort, int pinNum> // Отменяет привязку к типу порта, теперь можно сюда передать номер с любого порта (GPIOC, GPIOА)
class Pin: public IPin, public IPinReadable // Pin - класс наследник (наследование)
{
  public:
  void Set() //  устанавливает пин в 1
  {
    TPort::ODR::Set(1U << pinNum);
  }

  void Reset() const override
  {
    auto value = TPort::ODR::Get();
    value &=~(1U << pinNum);
    TPort::ODR::Write(value);
  }
  void Toggle() const override //override - переопределение функции, которые есть в наследуемом классе интерфейсе
  {
    TPort::ODR::Toggle(1U << pinNum);
  }

  bool IsHigh() const override // Считывание состояние ножки
  {
    auto value = TPort::IDR::Get(); //получили значение входного регистра с состоянием ножек,
    return ( (value & (1U << pinNum) ) == (1 << pinNum) ); // проверка на единичный бит
  }
};
#endif //Защита от двойного подключения заголовочного файла
-------

.Интерфейс ipin.h
[source, c++]
-------
// Интерфейс класса Pin
#ifndef IPIN_H
#define IPIN_H

class IPin
{
public:
  virtual void Reset() const=0;   //  Сбрасывает пин в 0
  virtual void Toggle() const=0 ; // виртуальный метод, у которого нет реализации
};
#endif
-------

.Интерфейс IPinReadable.h
[source, c++]
-------
// Интерфейс класса Считывание состояния кнопки
#ifndef IPINREADABLE_H
#define IPINREADABLE_H

class IPinReadable
{
public:
  virtual bool IsHigh() const=0;
};

#endif
-------

Вторая абстракция будет *LED*, у которого есть 2 состояния:
переключаться из состояния 1 в 0 и наоборот и гаснуть.
К тому же отдельный светодиод привязан к ножке процессора и при создании объекта типа LED
передадим объкту LED ножку порта к которой светодиод привязан.

Таким образом мы создаём класс *LED* и интерфейс *ILED* от которого будет наследоваться светодиод.

image::Создание объекта LED с интерфейсом ILED.PNG[]

.Интерфейс ILED.h
[source, c++]
-------
//Интерфейс класса Led
#ifndef ILED_H
#define ILED_H

class ILed
{
public:
  virtual void SwithOff() const=0; // виртуальный метод выключения светодиода
  virtual void Toggle() const=0; // виртуальный метод переключения светодиода из 1 в 0 или обратно
};
#endif
-------

В интерфейсе функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в файле *LED.cpp*.

.Заголовочный файл LED.h
[source, c++]
-------
#ifndef  LED_H
#define  LED_H

#include "ILED.h" // подключение интерфейса светодиода
#include "ipin.h" // подклчение интерфейса пина

class Led : public ILed // наследование LED от интерфейса ILED
{
public:
   Led(const IPin& pin) ; // конструктор в который передаётся ссылка на класс типа IPin

//----------Переопределяются, т.к. они уже есть в интерфейсе--------------------
   void SwithOff() const override; // переопределяемый метод выключение светодиода
   void Toggle() const override;  // переобпределяемый метод переключение светодиода
//------------------------------------------------------------------------------

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в LED.cpp)
    const IPin& _pin;
};
#endif
-------

.Исполняемый файл LED.сpp
[source, c++]
-------
#include "LED.h" // подключение заголовочного файла LED

Led::Led(const IPin& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// потушить светодиод
void Led::SwithOff() const
{
  _pin.Reset(); // у IPin есть метод Reset(), который сбрасывает пин в 0
}

// переключить светодиод
void Led::Toggle() const
{
  _pin.Toggle(); // у IPin есть метод Toggle(), который переключает пин из одного состояния в противоположное
}
-------

Затем создами *pinconfig.h* для того, чтобы здесь задавать привязку к пинам. Чтобы светодиоды были
привязаны только к абстрактному классу, а не к выводам микроконтроллера непосредственно.

.Класс pinconfig.h
[source, c++]
-------
#ifndef  PINCONFIG_H
#define  PINCONFIG_H

#include "pin.h"

//-----------------------------Светодиоды---------------------------------------
inline constexpr Pin<GPIOC, 6> pinC6;
inline constexpr Pin<GPIOC, 7> pinC7;
inline constexpr Pin<GPIOC, 8> pinC8;
inline constexpr Pin<GPIOC, 9> pinC9;
//------------------------------------------------------------------------------

inline constexpr Pin<GPIOC, 13> pinC13; // кнопка
#endif
-------

И напишем часть кода в main.cpp. Подключим необходимые заголовочники и создадим 4 объекта
светодиода, и из них массив.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами

// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
}
-------

Третья абстракция будет *Button*, у которого есть 1 метод *IsPressed()*, который показывает
состояние кнопки (кнопка нажата - возвращается true, кнопка не нажата - false).
Так же как и светодиод, кнопка использует пин микроконтроллера, поэтому будем передавать в конструктор
пины через интерфейс IPinReadable.
К тому же каждая отдельная кнопка привязана к ножке процессора и при создании объекта типа Button
передадим объкту Button ножку порта к которой кнопка привязана.

Таким образом мы создаём класс *Button* и интерфейс *IButton* от которого будет наследоваться кнопка.

image::Создание объекта Button и его интерфейса.PNG[]

.Интерфейс IButton.h
[source, c++]
-------
//Интерфейс класса кнопки
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton
{
public:
  virtual bool IsPressed() const=0; // // виртуальный метод, который возвращается значение, показывающее состояние кнопки (нажата или нет)
};

#endif
-------

.Заголовочный файл Button.h
[source, c++]
-------
#ifndef  BUTTON_H
#define  BUTTON_H

#include "IButton.h" // подключение интерфейса Button
#include "iPinReadable.h" // подключение интерфейса считывания

class Button : public IButton // наследование Button от интерфейса IButton
{
public:
  Button(const IPinReadable& pin) ; // конструктор в который передаётся ссылка на класс типа IPin
  bool IsPressed() const override; // переопределяющийся методы, который возвращает нажата ли кнопка

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в Button.cpp)
    const IPinReadable& _pin;
};

#endif
-------
В интерфейсе функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в файле *Button.cpp*.

.Класс Button.сpp
[source, c++]
-------
#include "Button.h" // подключение заголовочного файла Button

Button::Button(const IPinReadable& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// Кнопка нажата
bool Button::IsPressed() const
{
    if( !_pin.IsHigh() )  // Если кнопка не нажата
    {
        while (!_pin.IsHigh()) // Если в како-то момент времени кнопка нажалась, то режим меняем
        {
           volatile int a = 1; // ничего не делающая строчка, нужна для ожидания пока кнопка обратно не отпустится
        }
        return true;
    }
    return false;
}
-------
И в main.cpp добавим строчку, создания нового объекта кнопки, туда где создавали
объекты светодиодов:

.Класс main.сpp
[source, c++]
-------
...
//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
Button userButton1(pinC13); // Добавили объект кнопка
//------------------------------------------------------------------------------
...
-------

Четвёртой абстракцией будут режимы, у которых есть 2 общих метод *Clear()* и
*Update()*.

*Update()* позволяет обновить состояние светодиодов. Кадый режим содержит метод
*Update()*, поэтому его реализаця находится в интерфейсе *IMode*.

*Clear()* позволяет сбросить в 0 все светодиоды. Данный метод переопределяется
для режима в шахмотном порядке (ChessMose), потому что должен не все светодиоды
гасить а только через одного(либо все чётные, либо все нечётные).

Таким образом мы создаём 2 класса режимов *AllMode* (мигание всеми),
*ChessMode* (мигание в шахматном порядке) и интерфейс *IMode*
от которого будeт наследоваться все режимы.

image::Создание режимов.PNG[]

.Интерфейс IMode.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef IMODE_H
#define IMODE_H

#include <array> // подключение библиотеки массивов
#include "ILED.h" // подключение интерфейса LED

using tArrayLeds = std::array<ILed*,4>;

class IMode
{
public:
  IMode(const tArrayLeds& leds): _leds(leds) // инициализация ссылки на объекты-светодиоды
  {

  }
// Функция переключения светодиодов из одного состояния в другое
  virtual void Update() const
  {
     for(auto& it:_leds)
     {
        it->Toggle();
     }
  };
// Функция, выключающая светодиоды
  virtual void Clear() const
  {
    for(auto& it:_leds)
    {
       it->SwithOff();
    }
  };

protected:
   const tArrayLeds& _leds; // конструктор может использоваться только классами наследниками
};
#endif
-------

В данном интерфейсе функции и объявляются и реализуются.

Далее необходимо описать режим *AllMode*, который должен просто моргать всеми
светодиодами.

.Заголовочный файл AllMode.h
[source, c++]
-------
//заголовочный файл для режима "Моргать всеми"
#ifndef ALLMODE_H
#define ALLMODE_H

#include "IMode.h" // подключение интерфейса IMode
#include "iled.h" // подключение интерфейса LED

class AllMode: public IMode // наследование режима моргания от интерфейса IMode
{
public:
   AllMode(const tArrayLeds& leds) ; // Передача светодиодов в режим моргания
};
#endif
-------

.Исполняемый файл AllMode.сpp
[source, c++]
-------
#include "AllMode.h" // подключение заголовочника

AllMode::AllMode(const tArrayLeds& leds): IMode(leds) // наследование всех функций (методов) он интерфейса IMode
{
  
}
-------

Далее необходимо описать режим *ChessMode*, который должен моргать светодиодами
в шахматном порядке.

.Заголовочный файл ChessMode.h
[source, c++]
-------
//заголовочный файл для режима "Шахматы"
#ifndef CHESSMODE_H
#define CHESSMODE_H

#include "IMode.h" // подключение инерфейса IMode
#include  "ILED.h" // подключение интерфейса LED

class ChessMode: public IMode // наследование режима шахмат от интерфейса IMode
{
public:
   ChessMode(const tArrayLeds& led) ; // передача светодиодов в режим шахмат
   void Clear() const override ; // переопределённая функция выключения светодиодов
};
#endif
-------

.Исполняемый файл ChessMode.сpp
[source, c++]
-------
#include "ChessMode.h" // подключение заголовочника

ChessMode::ChessMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций (методов) от интерфейса IMode
{
  Clear(); // переопределённая функция
}

void ChessMode::Clear() const // реализация переопределённой функции
{
    for (std::uint32_t i = 0; i < std::size(_leds); ++i)
    {
      if ((i % 2) == 0)
      {
         _leds[i]->Toggle();
      }
    }
}
-------

Последняя абстракция *Garland*, у которого есть две функции:

- Update(), который обновляет состояние режима;
- SwithNextMode(), который переключает режим.

Таким образом мы создаём класс *Garland* в который будет передаваться массив из режимов.

image::Создание объекта Garland.png[]

.Заголовочный файл Garland.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef GARLAND_H
#define GARLAND_H

#include <array> // подключение библиотеки массивов
#include "IMode.h" // подключение интерфейса

static uint32_t inline modeNumber = 0; // счётчик режимов

using tArrayModes = std::array<IMode*, 2>; // передача массива из режимов
class Garland
{
public:
  Garland(const tArrayModes& modes): _modes(modes) // инициализация ссылки на массив режимов
  {

  }

  virtual void UpdateCurrentMode() const // обновление состояния текущего режима
  {
     _modes[modeNumber]->Update();
  };

  virtual void SwithNextMode() const // переключение режима на следующий
  {
       modeNumber = ( modeNumber == (_modes.size()-1)) ? 0 : ++modeNumber; // переключение режимов по циклу (от 1 до последнего и снова от 1)
       _modes[modeNumber]->Clear(); // сброс всех светодиодов
  };

protected:
   const tArrayModes& _modes; // ссылка на массив светодиодов доступна только классам наследникам
};
#endif
-------

И напишем код в main.cpp. Подключим необходимые заголовочники и создадим объекты:
светодиоды, кнопка, режимы и гирлянда.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла
#include  "Button.h" // для кнопки
#include "AllMode.h" // режим горят все
#include "ChessMode.h" // режим шахматы
#include "TreeMode.h" // режим ёлочка
#include "Garland.h" // гирлянда

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами
// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
Button userButton1(pinC13); // кнопка
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

//-------------Создание объектов (режимов) с массивом из светодиодов------------
  AllMode allMode(leds);
  ChessMode chessMode(leds);
//------------------------------------------------------------------------------

//----------------------------------Массив из режимов--------------------------
    using tArrayModes = std::array<IMode*,2>;
    tArrayModes modes =
    {
      &allMode,
      &chessMode,

    };
//------------------------------------------------------------------------------

//-------------Создание объекта (гирлянда) с привязкой к режимам----------------
  Garland garland(modes);
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  for(;;)  // вечный цикл
  {
    Delay(100000);
    if(userButton1.IsPressed()) // Если кнопка нажата
    {
      garland.SwithNextMode(); // Меняем режим
    }
    Delay(1000000);
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------

== Вывод
Я узнала что существуют 4 важных принципа ООП: абстракция, полиморфизм,
наследование и инкапсуляция, которые позволяют создавать красивый, читабельный
и коротки код.
Создала программу Гирлянда, которая управляет различными режимами. Программа
написана таким образом, чтобы была возможность добавлять новые режимы,
дополнительные пины.
Также большая часть программы полностью независима от железа. Зависимость
остаётся только на этапе подключения пинов и подачи тактирования (питания) на
ножки микроконтроллера.

