---
title: Отчёт 8
---

:reproducible:

:description: Project_8
:keywords: AsciiDoc
:imagesdir: Project_8
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[.notes]
С++ - объекто-ориентированный язык программирования, это означает, что он
построен на классах и объектах. И в нём действуют 4 главных правила:

1. Абстракция. Это создание и описание объекта и его функций (методов).
2. Наследование. Это, когда созданный объект перенимает свойства родительского объекта.
3. Инкапсуляция. Это сокрытие от пользователя функционала объектов, на
основе которых состоит более сложный объект.
4. Полиморфизм. Это присваение двум разным объектам одни и теже поведенческих функции (методы).


== Постановка задачи
Для того, чтобы написать правильно работающий код с возможностью
расширения функционала, необходимо продумать дизайн программы.
Продумка дизайна позволит писать код проще (т.е. строчки кода будут короче и читабельнее),
а также позволит адаптировать программу.

По заданию требуется написать программу "Гирлянда", которая может
управлять светодиодами, и по кнопке переключать режимы:

- мигание всеми светодиодами
- мигание светодиодами в шахматном порядке
- "Ёлочка"

Как уже было сказано, разработку программы стоит начинать с дизайна.
Для этих целей хорошо подойдёт UML диаграмма, котора позволит выстроить
логические цепочки.

Сперва необходимо определиться с абстракциями (т.е. существительными, объектами, которые
будут присутствовать в гирлянде). Любая абстракция представляется классом, который имеет описание.
В данном случае абстракциями будут:

- пины (Pin)
- кнопка (Button)
- светодиоды (LED)
- режимы (IMode)
- гирлянда (Garland)

Другими словами, мы создаём гирлянду, которая по нажатию кнопки, переключает режимы, которые
по-разному светят светодиодами, которые прикреплены к пину (ножке микроконтроллера).

Исходя из поставленной задачи будем по ней двигаться с конца в начало, для того, чтобы сперва
описать внутренние составляющие гирлянды (пины), затем светодиоды, затем режимы и в конце саму гирлянду.

Первая абстракция будет *Pin*, у которого есть 2 состояния: быть включенным и быть выключенным.
Так же, пин может переключаться из состояния 1 в 0 и наоборот, а ещё с пина можно считать его состояние.
К тому же пин привязан к порту и чтобы была возможность передавать на пин любой порт (GPIOA,
GPIOB, GPIOC и т.д.) с любым номером порта, можно создать шаблонный класс, в который будем передавать
порт и номер порта.

Таким образом мы создаём класс *pin* и два интерфейса от которых будет наследоваться пин:

- *IPinReadable*, который будет наследоваться пином, отвечающим за кнопку.
- *IPin*, который будет наследоваться пином, отвечающим за светодиод.

В этих интерфейсах функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в заголовочном файле *pin.h*.

.Создание класса *Pin* и интерфейсов *IPinReadable* и *IPin*
image::Создание объекта Pin и интерфейсов .png[]

.Класс pin.h
[source, c++]
-------
#ifndef PIN_H //Защита от двойного подключения заголовочного файла
#define PIN_H //Защита от двойного подключения заголовочного файла

#include "ipin.h" // подключение интерфейса
#include "IPinReadable.h" // подключение интерфейса

template<typename TPort, int pinNum> // Отменяет привязку к типу порта, теперь можно сюда передать номер с любого порта (GPIOC, GPIOА)
class Pin: public IPin, public IPinReadable // Pin - класс наследник (наследование)
{
  public:
  void Set() //  устанавливает пин в 1
  {
    TPort::ODR::Set(1U << pinNum);
  }

  void Reset() const override
  {
    auto value = TPort::ODR::Get();
    value &=~(1U << pinNum);
    TPort::ODR::Write(value);
  }
  void Toggle() const override //override - переопределение функции, которые есть в наследуемом классе интерфейсе
  {
    TPort::ODR::Toggle(1U << pinNum);
  }

  bool IsHigh() const override // Считывание состояние ножки
  {
    auto value = TPort::IDR::Get(); //получили значение входного регистра с состоянием ножек,
    return ( (value & (1U << pinNum) ) == (1 << pinNum) ); // проверка на единичный бит
  }
};
#endif //Защита от двойного подключения заголовочного файла
-------

.Интерфейс ipin.h
[source, c++]
-------
// Интерфейс класса Pin
#ifndef IPIN_H
#define IPIN_H

class IPin
{
public:
  virtual void Reset() const=0;   //  Сбрасывает пин в 0
  virtual void Toggle() const=0 ; // виртуальный метод, у которого нет реализации
};
#endif
-------

.Интерфейс IPinReadable.h
[source, c++]
-------
// Интерфейс класса Считывание состояния кнопки
#ifndef IPINREADABLE_H
#define IPINREADABLE_H

class IPinReadable
{
public:
  virtual bool IsHigh() const=0;
};

#endif
-------

Вторая абстракция будет *LED*, у которого есть 2 состояния:
переключаться из состояния 1 в 0 и наоборот и гаснуть.
К тому же отдельный светодиод привязан к ножке процессора и при создании объекта типа LED
передадим объкту LED ножку порта к которой светодиод привязан.


Таким образом мы создаём класс *LED* и интерфейс *ILED* от которого будет наследоваться светодиод.

image::Создание объекта LED с интерфейсом ILED.PNG[]

.Интерфейс ILED.h
[source, c++]
-------
//Интерфейс класса Led
#ifndef ILED_H
#define ILED_H

class ILed
{
public:
  virtual void SwithOff() const=0; // виртуальный метод выключения светодиода
  virtual void Toggle() const=0; // виртуальный метод переключения светодиода из 1 в 0 или обратно
};
#endif
-------

В интерфейсе функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в файле *LED.cpp*.

.Заголовочный файл LED.h
[source, c++]
-------
#ifndef  LED_H
#define  LED_H

#include "ILED.h" // подключение интерфейса светодиода
#include "ipin.h" // подклчение интерфейса пина

class Led : public ILed // наследование LED от интерфейса ILED
{
public:
   Led(const IPin& pin) ; // конструктор в который передаётся ссылка на класс типа IPin

//----------Переопределяются, т.к. они уже есть в интерфейсе--------------------
   void SwithOff() const override; // переопределяемый метод выключение светодиода
   void Toggle() const override;  // переобпределяемый метод переключение светодиода
//------------------------------------------------------------------------------

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в LED.cpp)
    const IPin& _pin;
};
#endif
-------

.Исполняемый файл LED.сpp
[source, c++]
-------
#include "LED.h" // подключение заголовочного файла LED

Led::Led(const IPin& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// потушить светодиод
void Led::SwithOff() const
{
  _pin.Reset(); // у IPin есть метод Reset(), который сбрасывает пин в 0
}

// переключить светодиод
void Led::Toggle() const
{
  _pin.Toggle(); // у IPin есть метод Toggle(), который переключает пин из одного состояния в противоположное
}
-------

Затем создами *pinconfig.h* для того, чтобы здесь задавать привязку к пинам. Чтобы светодиоды были
привязаны только к абстрактному классу, а не к выводам микроконтроллера непосредственно.

.Класс pinconfig.h
[source, c++]
-------
#ifndef  PINCONFIG_H
#define  PINCONFIG_H

#include "pin.h"

//-----------------------------Светодиоды---------------------------------------
inline constexpr Pin<GPIOC, 6> pinC6;
inline constexpr Pin<GPIOC, 7> pinC7;
inline constexpr Pin<GPIOC, 8> pinC8;
inline constexpr Pin<GPIOC, 9> pinC9;
//------------------------------------------------------------------------------

inline constexpr Pin<GPIOC, 13> pinC13; // кнопка
#endif
-------

И напишем часть кода в main.cpp. Подключим необходимые заголовочники и создадим 4 объекта
светодиода, и из них массив.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами

// -------------------------Функция задержки-----------------------------------
int Delay(int value)
{
  for(int i = 0;i<value;++i)
  {
    volatile int j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
}
-------

Третья абстракция будет *Button*, у которого есть 1 метод *IsPressed()*, который показывает
состояние кнопки (кнопка нажата - возвращается true, кнопка не нажата - false).
Так же как и светодиод, кнопка использует пин микроконтроллера, поэтому
К тому же отдельный светодиод привязан к ножке процессора и при создании объекта типа LED
передадим объкту LED ножку порта к которой светодиод привязан.


Таким образом мы создаём класс *LED* и интерфейс *ILED* от которого будет наследоваться светодиод.

image::Создание объекта Button и его интерфейса.PNG[]

.Интерфейс I.h
[source, c++]
-------

-------









Т.о. корректное использование типов данных позволяет избегать ошибок.
[Типы данных]
.Типы данных
[options="header"]
|=====================
|Тип|Количество бит|Диапазон
|unsigned char (без знаковый)|8        |0...255
|signed char (знаковый)|8        |-128...127
|char16_t (символ в кодировке Unicode)|16               |0...65 535
|char32_t (символ в кодировке Unicode)|32               |0...4 294 967 295
|unsigned int (без знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)|0...65 535 (для 2 байт), 0...4 294 967 295 (для 4 байт)
|signed int (знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)               |–32 768...32767 (при 2 байтах) или от −2 147 483 648...2 147 483 647 (при 4 байтах)
|float (вещественное число ординарной точности с плавающей точкой)|32               |- 3.4E-38...3.4E+38
|double (вещественное число двойной точности с плавающей точкой)|64               |- 1.7E-308...1.7E+308
|=====================

=== Выбор контролера
Для того чтобы можно было загружать код в плату необходимо настроить проект под наш микроконтроллер. Для этого нажмём правой кнопкой мыши по проекту и выберем Options->General Options->Target.
Выберем "Device" ST STM32F411RC. На вкладке Debugger выберем Driver "ST-LINK". И на вкладке ST-LINK выберем "SWD".


image::STM32F411RC.png[]
image::ST_LINK.png[]
image::SWD.png[]

=== Подключение платы

Плату необходимо подключить через отладчик, ибо он перепрошивает микроконтроллер.

.Подключение платы через отладчик по USB
image::ConnectBoard.png[]

=== Первая программа на плате
Для проверки работоспособности платы загрузим код из stm32Labs->Lab1->iarproject.ewd.

[source, c++]
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C"
{
    int __low_level_init(void)
    {
        //Switch on external 16 MHz oscillator
        RCC::CR::HSION::On::Set();
        while (RCC::CR::HSIRDY::NotReady::IsSet())
        {
        }
        //Switch system clock on external oscillator
        RCC::CFGR::SW::Hsi::Set();
        while (!RCC::CFGR::SWS::Hsi::IsSet())
        {
        }
        RCC::APB2ENR::SYSCFGEN::Enable::Set();
        return 1;
    }
}
void delay(int cycles)
{
    for(int i = 0; i < cycles; ++i)
    {
        asm volatile("");
    }
}
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
    //Порт 5.А на вывод
    GPIOA::MODER::MODER5::Output::Set() ;
    //Порт С.5, С.8, С.9 на вывод
    GPIOC::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER8::Output::Set() ;
    GPIOC::MODER::MODER9::Output::Set() ;
    for(;;)
    {
        GPIOA::ODR::ODR5::High::Set();
        GPIOC::ODR::ODR8::High::Set();
        delay(1000000);
        GPIOA::ODR::ODR5::Low::Set();
        GPIOC::ODR::ODR8::Low::Set();
        delay(1000000);
    }
    return 1;
}

Этот код позволяет мигать светодиодом.


video::MiganieLED.mp4[]

=== _forceinline
_forceinline - это макрос, который позволяет не делать функцию
как реальную, т.е. обычно при вызове функции компилятор идёт
внутрь этой функции и выполняет действия содержащиеся в ней.
Функция Set() из кода выше описывается функцией, которая находится
в файле "fieldvaluebase.hpp".
И для того, чтобы при отладке вместо функции Set() компилятор
не вставлял содержимое этой функции и прописывается данный макрос.
Этот макрос позволяет экономить ПЗУ.

== Вывод
Я научилась подключать плату к ноутбуку, настраивать среду
разработки в IAR, запускать отладчик, клонировать репозитории из гитхаба.
>>>>>>> dd41c8f31af8845b72ebcb1cc09e39e9ec954adc

